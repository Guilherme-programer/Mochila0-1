üéí Projeto do Problema da Mochila (Knapsack Problem)üéØ Vis√£o Geral do ProjetoEste reposit√≥rio cont√©m a implementa√ß√£o e an√°lise comparativa de tr√™s abordagens distintas para resolver o Problema da Mochila 0/1 (0/1 Knapsack Problem), um cl√°ssico problema de otimiza√ß√£o combinat√≥ria classificado como NP-Dif√≠cil:For√ßa Bruta (Brute Force): Solu√ß√£o exata com complexidade exponencial.Programa√ß√£o Din√¢mica (PD): Solu√ß√£o exata com complexidade pseudo-polinomial.Algoritmo Guloso (Greedy): Solu√ß√£o aproximada com complexidade polinomial.O objetivo do projeto √© demonstrar o trade-off entre otimalidade (qualidade da solu√ß√£o) e efici√™ncia (tempo de execu√ß√£o) atrav√©s da an√°lise de complexidade e testes emp√≠ricos.üíª Algoritmos e ComplexidadeAlgoritmoTipo de Solu√ß√£oComplexidade de Tempo (Te√≥rica)Melhor UsoFor√ßa Bruta (FB)Exata (√ìtima)$\mathcal{O}(N \cdot 2^N)$Apenas para $N \le 25$.Programa√ß√£o Din√¢mica (PD)Exata (√ìtima)$\mathcal{O}(N \cdot L)$Melhor para $N$ e $L$ pequenos.Algoritmo GulosoAproximada (Heur√≠stica)$\mathcal{O}(N \log N)$Melhor para $N$ ou $L$ muito grandes (escalabilidade).‚öôÔ∏è Estrutura do C√≥digoO projeto est√° implementado em Java e utiliza as seguintes classes e m√©todos principais:Arquivo/ClasseDescri√ß√£oPrincipais M√©todosMochilaForcaBruta.javaImplementa√ß√£o que testa todas as $2^N$ combina√ß√µes de itens.knapsackForcaBruta()MochilaPDTesteAltoN.javaImplementa√ß√£o do algoritmo de Programa√ß√£o Din√¢mica (PD) baseado na matriz de memoriza√ß√£o ($[N+1][L+1]$).knapsackPD()MochilaGuloso.javaImplementa√ß√£o da heur√≠stica Gulosa baseada na raz√£o custo-benef√≠cio ($u/p$).knapsackGuloso()Utilit√°riosgerarDados()Fun√ß√£o unificada para criar inst√¢ncias de teste aleat√≥rias e reprodut√≠veis.gravarDadosEmArquivo()üöÄ Como Executar o ProjetoPr√©-requisitosJava Development Kit (JDK): Vers√£o 17 ou superior.Ambiente de Desenvolvimento: Recomendado Visual Studio Code (VS Code) ou IntelliJ IDEA.Passos para Execu√ß√£oClone o Reposit√≥rio:Bashgit clone [LINK DO SEU REPOSIT√ìRIO]
cd [NOME DO REPOSIT√ìRIO]
Compile e Execute os Arquivos:Execute cada classe principal individualmente para ver os resultados de efici√™ncia. Exemplo:Bash# Teste de Efici√™ncia da Programa√ß√£o Din√¢mica (PD)
javac MochilaPDTesteAltoN.java
java MochilaPDTesteAltoN

# Teste de Efici√™ncia do Algoritmo Guloso
javac MochilaGuloso.java
java MochilaGuloso

# Teste de For√ßa Bruta (cuidado com o N > 25)
# javac MochilaForcaBruta.java
# java MochilaForcaBruta
Dados de TesteTodos os algoritmos utilizam a fun√ß√£o gerarDados() com uma **seed unificada** para garantir que a mesma inst√¢ncia de entrada seja usada na compara√ß√£o de qualidade (PD vs. Guloso).Inst√¢ncias Usadas:$N=1000, L=100$$N=1000, L=1000$Sa√≠da: Ap√≥s a execu√ß√£o, um arquivo de texto (.txt) contendo a lista completa de pesos e utilidades da inst√¢ncia gerada ser√° salvo na mesma pasta, permitindo a verifica√ß√£o dos dados.üìä Resultados e Conclus√£oOs testes emp√≠ricos confirmaram a an√°lise de complexidade te√≥rica.AlgoritmoInst√¢ncia (N,L)Tempo M√©dioQualidade da Solu√ß√£oObserva√ß√£oGuloso$1000, 100$$6 \text{ ms}$$100\%$Solu√ß√£o √≥tima devido √† restri√ß√£o de pesos.Guloso$1000, 1000$$6 \text{ ms}$$97.22\%$Demonstra o erro inerente √† aproxima√ß√£o.PD$1000, 100$$4 \text{ ms}$$100\%$Solu√ß√£o √≥tima, mais r√°pido devido ao $N \cdot L$ baixo.A escolha do algoritmo depende do objetivo: o Guloso √© ideal para escalabilidade em problemas massivos onde a otimalidade absoluta √© dispens√°vel (solu√ß√µes $\ge 97\%$), enquanto o PD √© o √∫nico m√©todo r√°pido para garantir a otimalidade da solu√ß√£o.üë• Contribui√ß√£oDesenvolvido por:[Seu Nome/Nome do Grupo]Data: Dezembro de 2025